# ======================
# ФУНКЦИИ ДЛЯ СИСТЕМЫ ПРОВЕРОК
# ======================

async def get_player_inspectors(user_id: int) -> List[int]:
    """Получить купленные уровни инспекторов игрока"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            "SELECT level FROM player_inspectors WHERE user_id = ? ORDER BY level",
            (user_id,)
        )
        rows = await cursor.fetchall()
        return [row[0] for row in rows]

async def buy_inspector_level(user_id: int, level: int) -> bool:
    """Купить уровень инспектора"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            await db.execute(
                "INSERT OR IGNORE INTO player_inspectors (user_id, level) VALUES (?, ?)",
                (user_id, level)
            )
            await db.commit()
            return True
        except:
            return False

async def get_player_protections(user_id: int) -> List[int]:
    """Получить купленные уровни защиты игрока"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            "SELECT level FROM player_protections WHERE user_id = ? ORDER BY level",
            (user_id,)
        )
        rows = await cursor.fetchall()
        return [row[0] for row in rows]

async def buy_protection_level(user_id: int, level: int) -> bool:
    """Купить уровень защиты"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            await db.execute(
                "INSERT OR IGNORE INTO player_protections (user_id, level) VALUES (?, ?)",
                (user_id, level)
            )
            await db.commit()
            return True
        except:
            return False

async def get_active_protection(user_id: int) -> Optional[Dict]:
    """Получить активную защиту игрока"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            "SELECT protection_level, activated_at, expires_at FROM active_protections WHERE user_id = ?",
            (user_id,)
        )
        row = await cursor.fetchone()
        if row:
            return {
                "protection_level": row[0],
                "activated_at": row[1],
                "expires_at": row[2]
            }
        return None

async def activate_protection(user_id: int, level: int, duration_minutes: int) -> bool:
    """Активировать защиту"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            activated_at = datetime.now()
            expires_at = activated_at + timedelta(minutes=duration_minutes)
            
            await db.execute(
                """INSERT OR REPLACE INTO active_protections 
                   (user_id, protection_level, activated_at, expires_at) 
                   VALUES (?, ?, ?, ?)""",
                (user_id, level, activated_at.isoformat(), expires_at.isoformat())
            )
            await db.commit()
            return True
        except:
            return False

async def get_inspection_stats(user_id: int) -> Dict:
    """Получить статистику проверок игрока"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            """SELECT total_inspections, successful_inspections, 
                      failed_inspections, halls_closed, inspections_today,
                      last_inspection, last_reset_date 
               FROM inspection_stats WHERE user_id = ?""",
            (user_id,)
        )
        row = await cursor.fetchone()
        if row:
            return {
                "total_inspections": row[0],
                "successful_inspections": row[1],
                "failed_inspections": row[2],
                "halls_closed": row[3],
                "inspections_today": row[4],
                "last_inspection": row[5],
                "last_reset_date": row[6]
            }
        
        # Создаем новую запись
        await db.execute(
            """INSERT INTO inspection_stats (user_id) VALUES (?)""",
            (user_id,)
        )
        await db.commit()
        return {
            "total_inspections": 0,
            "successful_inspections": 0,
            "failed_inspections": 0,
            "halls_closed": 0,
            "inspections_today": 0,
            "last_inspection": None,
            "last_reset_date": datetime.now().date().isoformat()
        }

async def update_inspection_stats(
    user_id: int, 
    successful: bool, 
    halls_closed: int = 0
) -> bool:
    """Обновить статистику проверок"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            # Сбрасываем дневной счетчик если нужно
            today = datetime.now().date().isoformat()
            await db.execute(
                """UPDATE inspection_stats 
                   SET inspections_today = 0, last_reset_date = ?
                   WHERE user_id = ? AND last_reset_date != ?""",
                (today, user_id, today)
            )
            
            # Обновляем статистику
            if successful:
                await db.execute(
                    """UPDATE inspection_stats 
                       SET total_inspections = total_inspections + 1,
                           successful_inspections = successful_inspections + 1,
                           halls_closed = halls_closed + ?,
                           inspections_today = inspections_today + 1,
                           last_inspection = ?
                       WHERE user_id = ?""",
                    (halls_closed, datetime.now().isoformat(), user_id)
                )
            else:
                await db.execute(
                    """UPDATE inspection_stats 
                       SET total_inspections = total_inspections + 1,
                           failed_inspections = failed_inspections + 1,
                           inspections_today = inspections_today + 1,
                           last_inspection = ?
                       WHERE user_id = ?""",
                    (datetime.now().isoformat(), user_id)
                )
            await db.commit()
            return True
        except Exception as e:
            print(f"Ошибка обновления статистики: {e}")
            return False

async def get_protection_stats(user_id: int) -> Dict:
    """Получить статистику защиты"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            "SELECT total_blocked, total_spent_on_protection FROM protection_stats WHERE user_id = ?",
            (user_id,)
        )
        row = await cursor.fetchone()
        if row:
            return {
                "total_blocked": row[0],
                "total_spent_on_protection": row[1]
            }
        
        # Создаем новую запись
        await db.execute(
            "INSERT INTO protection_stats (user_id) VALUES (?)",
            (user_id,)
        )
        await db.commit()
        return {
            "total_blocked": 0,
            "total_spent_on_protection": 0
        }

async def update_protection_stats(user_id: int, blocked: bool = False, spent: int = 0) -> bool:
    """Обновить статистику защиты"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            if blocked:
                await db.execute(
                    "UPDATE protection_stats SET total_blocked = total_blocked + 1 WHERE user_id = ?",
                    (user_id,)
                )
            if spent > 0:
                await db.execute(
                    "UPDATE protection_stats SET total_spent_on_protection = total_spent_on_protection + ? WHERE user_id = ?",
                    (spent, user_id)
                )
            await db.commit()
            return True
        except:
            return False

async def get_inspection_time_mode() -> Dict:
    """Получить статус режима 'Время проверок'"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        cursor = await db.execute(
            "SELECT is_active, started_at, ends_at FROM inspection_time_mode ORDER BY id DESC LIMIT 1"
        )
        row = await cursor.fetchone()
        if row:
            return {
                "is_active": bool(row[0]),
                "started_at": row[1],
                "ends_at": row[2]
            }
        
        # Создаем запись по умолчанию
        await db.execute(
            "INSERT INTO inspection_time_mode (is_active) VALUES (0)"
        )
        await db.commit()
        return {
            "is_active": False,
            "started_at": None,
            "ends_at": None
        }

async def set_inspection_time_mode(is_active: bool, duration_hours: int = 24) -> bool:
    """Установить режим 'Время проверок'"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        try:
            started_at = datetime.now()
            ends_at = started_at + timedelta(hours=duration_hours)
            
            # Деактивируем все предыдущие записи
            await db.execute("UPDATE inspection_time_mode SET is_active = 0")
            
            # Создаем новую запись
            await db.execute(
                """INSERT INTO inspection_time_mode (is_active, started_at, ends_at) 
                   VALUES (?, ?, ?)""",
                (1 if is_active else 0, started_at.isoformat(), ends_at.isoformat())
            )
            await db.commit()
            return True
        except Exception as e:
            print(f"Ошибка установки режима: {e}")
            return False

async def cleanup_expired_protections():
    """Очистить истекшие защиты"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        await db.execute(
            "DELETE FROM active_protections WHERE expires_at < ?",
            (datetime.now().isoformat(),)
        )
        await db.commit()

async def reset_daily_inspections():
    """Сбросить дневные счетчики проверок"""
    async with aiosqlite.connect(settings.DB_PATH) as db:
        today = datetime.now().date().isoformat()
        await db.execute(
            """UPDATE inspection_stats 
               SET inspections_today = 0, last_reset_date = ?
               WHERE last_reset_date != ?""",
            (today, today)
        )
        await db.commit()
